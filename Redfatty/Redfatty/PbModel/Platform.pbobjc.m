// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: platform.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Platform.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PlatformRoot

@implementation PlatformRoot

@end

#pragma mark - PlatformRoot_FileDescriptor

static GPBFileDescriptor *PlatformRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"common"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - PServiceStatus

@implementation PServiceStatus

@dynamic status, status_Count;

typedef struct PServiceStatus__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *status;
} PServiceStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(PService),
        .number = PServiceStatus_FieldNumber_Status,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PServiceStatus__storage_, status),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PServiceStatus class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PServiceStatus__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PService

@implementation PService

@dynamic status;
@dynamic canDo;

typedef struct PService__storage_ {
  uint32_t _has_storage_[1];
} PService__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PService_FieldNumber_Status,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "canDo",
        .dataTypeSpecific.className = NULL,
        .number = PService_FieldNumber_CanDo,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PService class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PService__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportNewsList

@implementation PReportNewsList

@dynamic listArray, listArray_Count;
@dynamic total;

typedef struct PReportNewsList__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  NSMutableArray *listArray;
} PReportNewsList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PReportNews),
        .number = PReportNewsList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportNewsList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PReportNewsList_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PReportNewsList__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportNewsList class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportNewsList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportNews

@implementation PReportNews

@dynamic id_p;
@dynamic informersArray, informersArray_Count;
@dynamic tuid;
@dynamic postid;
@dynamic isProcess;

typedef struct PReportNews__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *informersArray;
  NSString *tuid;
  int64_t id_p;
  int64_t postid;
  int64_t isProcess;
} PReportNews__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PReportNews_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PReportNews__storage_, id_p),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "informersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PInformer),
        .number = PReportNews_FieldNumber_InformersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportNews__storage_, informersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tuid",
        .dataTypeSpecific.className = NULL,
        .number = PReportNews_FieldNumber_Tuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PReportNews__storage_, tuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "postid",
        .dataTypeSpecific.className = NULL,
        .number = PReportNews_FieldNumber_Postid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PReportNews__storage_, postid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isProcess",
        .dataTypeSpecific.className = NULL,
        .number = PReportNews_FieldNumber_IsProcess,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PReportNews__storage_, isProcess),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportNews class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportNews__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000ID\000\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportUserList

@implementation PReportUserList

@dynamic listArray, listArray_Count;

typedef struct PReportUserList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PReportUserList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PReportUser),
        .number = PReportUserList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportUserList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportUserList class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportUserList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportUser

@implementation PReportUser

@dynamic id_p;
@dynamic informersArray, informersArray_Count;
@dynamic uuid;
@dynamic content;
@dynamic isProcess;

typedef struct PReportUser__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *informersArray;
  NSString *uuid;
  NSString *content;
  int64_t id_p;
  int64_t isProcess;
} PReportUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PReportUser_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PReportUser__storage_, id_p),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "informersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PInformer),
        .number = PReportUser_FieldNumber_InformersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportUser__storage_, informersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PReportUser_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PReportUser__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PReportUser_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PReportUser__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isProcess",
        .dataTypeSpecific.className = NULL,
        .number = PReportUser_FieldNumber_IsProcess,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PReportUser__storage_, isProcess),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportUser class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportUser__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000ID\000\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportCommunityUserList

@implementation PReportCommunityUserList

@dynamic listArray, listArray_Count;

typedef struct PReportCommunityUserList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PReportCommunityUserList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PReportCommunityUser),
        .number = PReportCommunityUserList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportCommunityUserList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportCommunityUserList class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportCommunityUserList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportCommunityUser

@implementation PReportCommunityUser

@dynamic id_p;
@dynamic informersArray, informersArray_Count;
@dynamic communityId;
@dynamic uuid;
@dynamic content;
@dynamic isProcess;

typedef struct PReportCommunityUser__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *informersArray;
  NSString *communityId;
  NSString *uuid;
  NSString *content;
  int64_t id_p;
  int64_t isProcess;
} PReportCommunityUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityUser_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PReportCommunityUser__storage_, id_p),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "informersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PInformer),
        .number = PReportCommunityUser_FieldNumber_InformersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportCommunityUser__storage_, informersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "communityId",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityUser_FieldNumber_CommunityId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PReportCommunityUser__storage_, communityId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityUser_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PReportCommunityUser__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityUser_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PReportCommunityUser__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isProcess",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityUser_FieldNumber_IsProcess,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PReportCommunityUser__storage_, isProcess),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportCommunityUser class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportCommunityUser__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000ID\000\003\nA\000\006\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportCommunityPostsList

@implementation PReportCommunityPostsList

@dynamic listArray, listArray_Count;

typedef struct PReportCommunityPostsList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PReportCommunityPostsList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PReportCommunityPosts),
        .number = PReportCommunityPostsList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportCommunityPostsList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportCommunityPostsList class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportCommunityPostsList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportCommunityPosts

@implementation PReportCommunityPosts

@dynamic id_p;
@dynamic informersArray, informersArray_Count;
@dynamic communityId;
@dynamic postsId;
@dynamic uuid;
@dynamic content;
@dynamic isProcess;

typedef struct PReportCommunityPosts__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *informersArray;
  NSString *communityId;
  NSString *postsId;
  NSString *uuid;
  NSString *content;
  int64_t id_p;
  int64_t isProcess;
} PReportCommunityPosts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityPosts_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PReportCommunityPosts__storage_, id_p),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "informersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PInformer),
        .number = PReportCommunityPosts_FieldNumber_InformersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportCommunityPosts__storage_, informersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "communityId",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityPosts_FieldNumber_CommunityId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PReportCommunityPosts__storage_, communityId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "postsId",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityPosts_FieldNumber_PostsId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PReportCommunityPosts__storage_, postsId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityPosts_FieldNumber_Uuid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PReportCommunityPosts__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityPosts_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PReportCommunityPosts__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isProcess",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityPosts_FieldNumber_IsProcess,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PReportCommunityPosts__storage_, isProcess),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportCommunityPosts class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportCommunityPosts__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\000ID\000\003\nA\000\004\006A\000\007\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportCommunityCommentList

@implementation PReportCommunityCommentList

@dynamic listArray, listArray_Count;

typedef struct PReportCommunityCommentList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PReportCommunityCommentList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PReportCommunityComment),
        .number = PReportCommunityCommentList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportCommunityCommentList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportCommunityCommentList class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportCommunityCommentList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PReportCommunityComment

@implementation PReportCommunityComment

@dynamic id_p;
@dynamic informersArray, informersArray_Count;
@dynamic communityId;
@dynamic postsId;
@dynamic commentId;
@dynamic uuid;
@dynamic content;
@dynamic isProcess;

typedef struct PReportCommunityComment__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *informersArray;
  NSString *communityId;
  NSString *postsId;
  NSString *commentId;
  NSString *uuid;
  NSString *content;
  int64_t id_p;
  int64_t isProcess;
} PReportCommunityComment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityComment_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PReportCommunityComment__storage_, id_p),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "informersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PInformer),
        .number = PReportCommunityComment_FieldNumber_InformersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PReportCommunityComment__storage_, informersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "communityId",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityComment_FieldNumber_CommunityId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PReportCommunityComment__storage_, communityId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "postsId",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityComment_FieldNumber_PostsId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PReportCommunityComment__storage_, postsId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityComment_FieldNumber_CommentId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PReportCommunityComment__storage_, commentId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityComment_FieldNumber_Uuid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PReportCommunityComment__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityComment_FieldNumber_Content,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PReportCommunityComment__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isProcess",
        .dataTypeSpecific.className = NULL,
        .number = PReportCommunityComment_FieldNumber_IsProcess,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PReportCommunityComment__storage_, isProcess),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PReportCommunityComment class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PReportCommunityComment__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\000ID\000\003\nA\000\004\006A\000\005\010A\000\010\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PInformer

@implementation PInformer

@dynamic uuid;
@dynamic time;

typedef struct PInformer__storage_ {
  uint32_t _has_storage_[1];
  NSString *uuid;
  int64_t time;
} PInformer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PInformer_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PInformer__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PInformer_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PInformer__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PInformer class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PInformer__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PKeywords

@implementation PKeywords

@dynamic listArray, listArray_Count;
@dynamic total;

typedef struct PKeywords__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  NSMutableArray *listArray;
} PKeywords__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PKeyword),
        .number = PKeywords_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PKeywords__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PKeywords_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PKeywords__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PKeywords class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PKeywords__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PKeyword

@implementation PKeyword

@dynamic id_p;
@dynamic work;

typedef struct PKeyword__storage_ {
  uint32_t _has_storage_[1];
  NSString *work;
  int64_t id_p;
} PKeyword__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PKeyword_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PKeyword__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "work",
        .dataTypeSpecific.className = NULL,
        .number = PKeyword_FieldNumber_Work,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PKeyword__storage_, work),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PKeyword class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PKeyword__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBlacklists

@implementation PBlacklists

@dynamic listArray, listArray_Count;
@dynamic total;

typedef struct PBlacklists__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  NSMutableArray *listArray;
} PBlacklists__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Pblacklist),
        .number = PBlacklists_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PBlacklists__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PBlacklists_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PBlacklists__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBlacklists class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBlacklists__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Pblacklist

@implementation Pblacklist

@dynamic id_p;
@dynamic val;
@dynamic other;

typedef struct Pblacklist__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *val;
  NSString *other;
} Pblacklist__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Pblacklist_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Pblacklist__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "val",
        .dataTypeSpecific.className = NULL,
        .number = Pblacklist_FieldNumber_Val,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Pblacklist__storage_, val),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "other",
        .dataTypeSpecific.className = NULL,
        .number = Pblacklist_FieldNumber_Other,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Pblacklist__storage_, other),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Pblacklist class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Pblacklist__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRecommendGame

@implementation PRecommendGame

@dynamic id_p;
@dynamic name;
@dynamic head;
@dynamic desc;

typedef struct PRecommendGame__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *name;
  NSString *head;
  NSString *desc;
} PRecommendGame__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendGame_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRecommendGame__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendGame_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PRecommendGame__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "head",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendGame_FieldNumber_Head,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PRecommendGame__storage_, head),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendGame_FieldNumber_Desc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PRecommendGame__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRecommendGame class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRecommendGame__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRecommendGameList

@implementation PRecommendGameList

@dynamic listArray, listArray_Count;

typedef struct PRecommendGameList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PRecommendGameList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PRecommendGame),
        .number = PRecommendGameList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PRecommendGameList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRecommendGameList class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRecommendGameList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRecommendClub

@implementation PRecommendClub

@dynamic id_p;
@dynamic name;
@dynamic head;
@dynamic desc;

typedef struct PRecommendClub__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *name;
  NSString *head;
  NSString *desc;
} PRecommendClub__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendClub_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRecommendClub__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendClub_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PRecommendClub__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "head",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendClub_FieldNumber_Head,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PRecommendClub__storage_, head),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendClub_FieldNumber_Desc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PRecommendClub__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRecommendClub class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRecommendClub__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRecommendClubList

@implementation PRecommendClubList

@dynamic listArray, listArray_Count;

typedef struct PRecommendClubList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PRecommendClubList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PRecommendClub),
        .number = PRecommendClubList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PRecommendClubList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRecommendClubList class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRecommendClubList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRecommendStar

@implementation PRecommendStar

@dynamic id_p;
@dynamic uuid;

typedef struct PRecommendStar__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *uuid;
} PRecommendStar__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendStar_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRecommendStar__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendStar_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PRecommendStar__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRecommendStar class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRecommendStar__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRecommendStarList

@implementation PRecommendStarList

@dynamic listArray, listArray_Count;

typedef struct PRecommendStarList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PRecommendStarList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PRecommendStar),
        .number = PRecommendStarList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PRecommendStarList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRecommendStarList class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRecommendStarList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

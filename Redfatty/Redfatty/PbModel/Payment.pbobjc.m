// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: payment.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Payment.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PaymentRoot

@implementation PaymentRoot

@end

#pragma mark - PaymentRoot_FileDescriptor

static GPBFileDescriptor *PaymentRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"common"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - PWeixinPay

@implementation PWeixinPay

@dynamic appid;
@dynamic partnerid;
@dynamic noncestr;
@dynamic timestamp;
@dynamic prepayid;
@dynamic package;
@dynamic sign;
@dynamic orderNo;

typedef struct PWeixinPay__storage_ {
  uint32_t _has_storage_[1];
  NSString *appid;
  NSString *partnerid;
  NSString *noncestr;
  NSString *timestamp;
  NSString *prepayid;
  NSString *package;
  NSString *sign;
  NSString *orderNo;
} PWeixinPay__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appid",
        .dataTypeSpecific.className = NULL,
        .number = PWeixinPay_FieldNumber_Appid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PWeixinPay__storage_, appid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "partnerid",
        .dataTypeSpecific.className = NULL,
        .number = PWeixinPay_FieldNumber_Partnerid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PWeixinPay__storage_, partnerid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noncestr",
        .dataTypeSpecific.className = NULL,
        .number = PWeixinPay_FieldNumber_Noncestr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PWeixinPay__storage_, noncestr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PWeixinPay_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PWeixinPay__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "prepayid",
        .dataTypeSpecific.className = NULL,
        .number = PWeixinPay_FieldNumber_Prepayid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PWeixinPay__storage_, prepayid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "package",
        .dataTypeSpecific.className = NULL,
        .number = PWeixinPay_FieldNumber_Package,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PWeixinPay__storage_, package),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = PWeixinPay_FieldNumber_Sign,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PWeixinPay__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderNo",
        .dataTypeSpecific.className = NULL,
        .number = PWeixinPay_FieldNumber_OrderNo,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PWeixinPay__storage_, orderNo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PWeixinPay class]
                                     rootClass:[PaymentRoot class]
                                          file:PaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PWeixinPay__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PAlipayOrderInfo

@implementation PAlipayOrderInfo

@dynamic orderNo;
@dynamic payInfo;

typedef struct PAlipayOrderInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *orderNo;
  NSString *payInfo;
} PAlipayOrderInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "orderNo",
        .dataTypeSpecific.className = NULL,
        .number = PAlipayOrderInfo_FieldNumber_OrderNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PAlipayOrderInfo__storage_, orderNo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payInfo",
        .dataTypeSpecific.className = NULL,
        .number = PAlipayOrderInfo_FieldNumber_PayInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PAlipayOrderInfo__storage_, payInfo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PAlipayOrderInfo class]
                                     rootClass:[PaymentRoot class]
                                          file:PaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PAlipayOrderInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PPayOrderList

@implementation PPayOrderList

@dynamic payOrdersArray, payOrdersArray_Count;

typedef struct PPayOrderList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *payOrdersArray;
} PPayOrderList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payOrdersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PPayOrder),
        .number = PPayOrderList_FieldNumber_PayOrdersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PPayOrderList__storage_, payOrdersArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PPayOrderList class]
                                     rootClass:[PaymentRoot class]
                                          file:PaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PPayOrderList__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000payOrders\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PPayOrder

@implementation PPayOrder

@dynamic orderNo;
@dynamic payType;
@dynamic orderSubject;
@dynamic orderBody;
@dynamic amount;
@dynamic payTime;
@dynamic payStatu;
@dynamic bankType;
@dynamic totalFee;
@dynamic errCodeDes;
@dynamic endTime;

typedef struct PPayOrder__storage_ {
  uint32_t _has_storage_[1];
  int32_t payStatu;
  NSString *orderNo;
  NSString *payType;
  NSString *orderSubject;
  NSString *orderBody;
  NSString *bankType;
  NSString *errCodeDes;
  int64_t amount;
  int64_t payTime;
  int64_t totalFee;
  int64_t endTime;
} PPayOrder__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "orderNo",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_OrderNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, orderNo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payType",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_PayType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, payType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderSubject",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_OrderSubject,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, orderSubject),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderBody",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_OrderBody,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, orderBody),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_Amount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "payTime",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_PayTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, payTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "payStatu",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_PayStatu,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, payStatu),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bankType",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_BankType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, bankType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalFee",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_TotalFee,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, totalFee),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "errCodeDes",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_ErrCodeDes,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, errCodeDes),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PPayOrder_FieldNumber_EndTime,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PPayOrder__storage_, endTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PPayOrder class]
                                     rootClass:[PaymentRoot class]
                                          file:PaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PPayOrder__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001\007\000\002\007\000\003\014\000\004\t\000\006\007\000\007\010\000\010\010\000\t\010\000\n\n\000\013\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wallet.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Wallet.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - WalletRoot

@implementation WalletRoot

@end

#pragma mark - WalletRoot_FileDescriptor

static GPBFileDescriptor *WalletRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"common"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - PDiamondTotalCount

@implementation PDiamondTotalCount

@dynamic totalVmoney;

typedef struct PDiamondTotalCount__storage_ {
  uint32_t _has_storage_[1];
  int64_t totalVmoney;
} PDiamondTotalCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalVmoney",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondTotalCount_FieldNumber_TotalVmoney,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PDiamondTotalCount__storage_, totalVmoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PDiamondTotalCount class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PDiamondTotalCount__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PDiamondCount

@implementation PDiamondCount

@dynamic totalVmoney;
@dynamic incomeVmoney;
@dynamic expendVmoney;

typedef struct PDiamondCount__storage_ {
  uint32_t _has_storage_[1];
  int32_t incomeVmoney;
  int32_t expendVmoney;
  int64_t totalVmoney;
} PDiamondCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalVmoney",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondCount_FieldNumber_TotalVmoney,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PDiamondCount__storage_, totalVmoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "incomeVmoney",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondCount_FieldNumber_IncomeVmoney,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PDiamondCount__storage_, incomeVmoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "expendVmoney",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondCount_FieldNumber_ExpendVmoney,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PDiamondCount__storage_, expendVmoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PDiamondCount class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PDiamondCount__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006E\000\002\007E\000\003\007E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PDiamondInfo

@implementation PDiamondInfo

@dynamic sid;
@dynamic uuid;
@dynamic name;
@dynamic type;
@dynamic target;
@dynamic headImgURL;
@dynamic vMoney;
@dynamic createTime;

typedef struct PDiamondInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t target;
  int32_t vMoney;
  NSString *sid;
  NSString *uuid;
  NSString *name;
  NSString *headImgURL;
  int64_t createTime;
} PDiamondInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sid",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondInfo_FieldNumber_Sid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PDiamondInfo__storage_, sid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondInfo_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PDiamondInfo__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondInfo_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PDiamondInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondInfo_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PDiamondInfo__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondInfo_FieldNumber_Target,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PDiamondInfo__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondInfo_FieldNumber_HeadImgURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PDiamondInfo__storage_, headImgURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vMoney",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondInfo_FieldNumber_VMoney,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PDiamondInfo__storage_, vMoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = PDiamondInfo_FieldNumber_CreateTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PDiamondInfo__storage_, createTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PDiamondInfo class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PDiamondInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\006\n\000\007\006\000\010\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PDiamondInfoList

@implementation PDiamondInfoList

@dynamic listArray, listArray_Count;

typedef struct PDiamondInfoList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PDiamondInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PDiamondInfo),
        .number = PDiamondInfoList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PDiamondInfoList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PDiamondInfoList class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PDiamondInfoList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRedPacketCount

@implementation PRedPacketCount

@dynamic recvVmoney;
@dynamic recvCount;
@dynamic sendVmoney;
@dynamic sendCount;

typedef struct PRedPacketCount__storage_ {
  uint32_t _has_storage_[1];
  int32_t recvVmoney;
  int32_t recvCount;
  int32_t sendVmoney;
  int32_t sendCount;
} PRedPacketCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recvVmoney",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketCount_FieldNumber_RecvVmoney,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRedPacketCount__storage_, recvVmoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "recvCount",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketCount_FieldNumber_RecvCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PRedPacketCount__storage_, recvCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sendVmoney",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketCount_FieldNumber_SendVmoney,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PRedPacketCount__storage_, sendVmoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sendCount",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketCount_FieldNumber_SendCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PRedPacketCount__storage_, sendCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRedPacketCount class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRedPacketCount__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\005E\000\002\t\000\003\005E\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRedPacketID

@implementation PRedPacketID

@dynamic rid;

typedef struct PRedPacketID__storage_ {
  uint32_t _has_storage_[1];
  NSString *rid;
} PRedPacketID__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rid",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketID_FieldNumber_Rid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRedPacketID__storage_, rid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRedPacketID class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRedPacketID__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PSendRedPacket

@implementation PSendRedPacket

@dynamic paytoken;
@dynamic type;
@dynamic count;
@dynamic vMoney;
@dynamic remark;
@dynamic target;
@dynamic targetId;

typedef struct PSendRedPacket__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t count;
  int32_t vMoney;
  int32_t target;
  NSString *paytoken;
  NSString *remark;
  NSString *targetId;
} PSendRedPacket__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paytoken",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacket_FieldNumber_Paytoken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PSendRedPacket__storage_, paytoken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacket_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PSendRedPacket__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacket_FieldNumber_Count,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PSendRedPacket__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "vMoney",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacket_FieldNumber_VMoney,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PSendRedPacket__storage_, vMoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacket_FieldNumber_Remark,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PSendRedPacket__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacket_FieldNumber_Target,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PSendRedPacket__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacket_FieldNumber_TargetId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PSendRedPacket__storage_, targetId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PSendRedPacket class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PSendRedPacket__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\006\000\007\007A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRedPacketInfo

@implementation PRedPacketInfo

@dynamic sid;
@dynamic rid;
@dynamic uuid;
@dynamic name;
@dynamic type;
@dynamic target;
@dynamic headImgURL;
@dynamic vMoney;
@dynamic remark;
@dynamic createTime;

typedef struct PRedPacketInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t target;
  NSString *sid;
  NSString *rid;
  NSString *uuid;
  NSString *name;
  NSString *headImgURL;
  NSString *remark;
  int64_t vMoney;
  int64_t createTime;
} PRedPacketInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sid",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_Sid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, sid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rid",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_Rid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, rid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_Target,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_HeadImgURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, headImgURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vMoney",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_VMoney,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, vMoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_Remark,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketInfo_FieldNumber_CreateTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PRedPacketInfo__storage_, createTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRedPacketInfo class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRedPacketInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\007\n\000\010\006\000\n\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PSendRedPacketInfo

@implementation PSendRedPacketInfo

@dynamic uuid;
@dynamic type;
@dynamic target;
@dynamic vMoney;
@dynamic count;
@dynamic remark;
@dynamic createTime;

typedef struct PSendRedPacketInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t target;
  int32_t count;
  NSString *uuid;
  NSString *remark;
  int64_t vMoney;
  int64_t createTime;
} PSendRedPacketInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacketInfo_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PSendRedPacketInfo__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacketInfo_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PSendRedPacketInfo__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacketInfo_FieldNumber_Target,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PSendRedPacketInfo__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "vMoney",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacketInfo_FieldNumber_VMoney,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PSendRedPacketInfo__storage_, vMoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacketInfo_FieldNumber_Count,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PSendRedPacketInfo__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacketInfo_FieldNumber_Remark,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PSendRedPacketInfo__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = PSendRedPacketInfo_FieldNumber_CreateTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PSendRedPacketInfo__storage_, createTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PSendRedPacketInfo class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PSendRedPacketInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\006\000\007\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRedPacketInfoList

@implementation PRedPacketInfoList

@dynamic listArray, listArray_Count;

typedef struct PRedPacketInfoList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PRedPacketInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PRedPacketInfo),
        .number = PRedPacketInfoList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PRedPacketInfoList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRedPacketInfoList class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRedPacketInfoList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRedPacketParticipant

@implementation PRedPacketParticipant

@dynamic uuid;
@dynamic name;
@dynamic headImgURL;
@dynamic vMoney;
@dynamic remark;
@dynamic createTime;

typedef struct PRedPacketParticipant__storage_ {
  uint32_t _has_storage_[1];
  int32_t vMoney;
  NSString *uuid;
  NSString *name;
  NSString *headImgURL;
  NSString *remark;
  int64_t createTime;
} PRedPacketParticipant__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketParticipant_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRedPacketParticipant__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketParticipant_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PRedPacketParticipant__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketParticipant_FieldNumber_HeadImgURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PRedPacketParticipant__storage_, headImgURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vMoney",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketParticipant_FieldNumber_VMoney,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PRedPacketParticipant__storage_, vMoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketParticipant_FieldNumber_Remark,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PRedPacketParticipant__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketParticipant_FieldNumber_CreateTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PRedPacketParticipant__storage_, createTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRedPacketParticipant class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRedPacketParticipant__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\n\000\004\006\000\006\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRedPacketDetail

@implementation PRedPacketDetail

@dynamic rid;
@dynamic uuid;
@dynamic name;
@dynamic headImgURL;
@dynamic vMoney;
@dynamic status;
@dynamic remark;
@dynamic hasInfo, info;
@dynamic listArray, listArray_Count;

typedef struct PRedPacketDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t vMoney;
  int32_t status;
  NSString *rid;
  NSString *uuid;
  NSString *name;
  NSString *headImgURL;
  NSString *remark;
  PSendRedPacketInfo *info;
  NSMutableArray *listArray;
} PRedPacketDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rid",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketDetail_FieldNumber_Rid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRedPacketDetail__storage_, rid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketDetail_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PRedPacketDetail__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketDetail_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PRedPacketDetail__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketDetail_FieldNumber_HeadImgURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PRedPacketDetail__storage_, headImgURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vMoney",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketDetail_FieldNumber_VMoney,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PRedPacketDetail__storage_, vMoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketDetail_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PRedPacketDetail__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketDetail_FieldNumber_Remark,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PRedPacketDetail__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PSendRedPacketInfo),
        .number = PRedPacketDetail_FieldNumber_Info,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PRedPacketDetail__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PRedPacketParticipant),
        .number = PRedPacketDetail_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PRedPacketDetail__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRedPacketDetail class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRedPacketDetail__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\n\000\005\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PWalletGiftTotalCount

@implementation PWalletGiftTotalCount

@dynamic totalCount;

typedef struct PWalletGiftTotalCount__storage_ {
  uint32_t _has_storage_[1];
  int32_t totalCount;
} PWalletGiftTotalCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalCount",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftTotalCount_FieldNumber_TotalCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PWalletGiftTotalCount__storage_, totalCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PWalletGiftTotalCount class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PWalletGiftTotalCount__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PWalletGiftCount

@implementation PWalletGiftCount

@dynamic totalCount;
@dynamic recvVmoney;
@dynamic recvCount;
@dynamic sendVmoney;
@dynamic sendCount;

typedef struct PWalletGiftCount__storage_ {
  uint32_t _has_storage_[1];
  int32_t totalCount;
  int32_t recvVmoney;
  int32_t recvCount;
  int32_t sendVmoney;
  int32_t sendCount;
} PWalletGiftCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalCount",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftCount_FieldNumber_TotalCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PWalletGiftCount__storage_, totalCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "recvVmoney",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftCount_FieldNumber_RecvVmoney,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PWalletGiftCount__storage_, recvVmoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "recvCount",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftCount_FieldNumber_RecvCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PWalletGiftCount__storage_, recvCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sendVmoney",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftCount_FieldNumber_SendVmoney,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PWalletGiftCount__storage_, sendVmoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sendCount",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftCount_FieldNumber_SendCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PWalletGiftCount__storage_, sendCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PWalletGiftCount class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PWalletGiftCount__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\n\000\002\005E\000\003\t\000\004\005E\000\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PWalletGiftInfo

@implementation PWalletGiftInfo

@dynamic sid;
@dynamic uuid;
@dynamic name;
@dynamic headImgURL;
@dynamic gid;
@dynamic vMoney;
@dynamic count;
@dynamic createTime;

typedef struct PWalletGiftInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t gid;
  int32_t vMoney;
  int32_t count;
  NSString *sid;
  NSString *uuid;
  NSString *name;
  NSString *headImgURL;
  int64_t createTime;
} PWalletGiftInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sid",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftInfo_FieldNumber_Sid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PWalletGiftInfo__storage_, sid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftInfo_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PWalletGiftInfo__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftInfo_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PWalletGiftInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftInfo_FieldNumber_HeadImgURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PWalletGiftInfo__storage_, headImgURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gid",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftInfo_FieldNumber_Gid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PWalletGiftInfo__storage_, gid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "vMoney",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftInfo_FieldNumber_VMoney,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PWalletGiftInfo__storage_, vMoney),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftInfo_FieldNumber_Count,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PWalletGiftInfo__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = PWalletGiftInfo_FieldNumber_CreateTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PWalletGiftInfo__storage_, createTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PWalletGiftInfo class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PWalletGiftInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\n\000\006\006\000\010\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PWalletGiftInfoList

@implementation PWalletGiftInfoList

@dynamic listArray, listArray_Count;

typedef struct PWalletGiftInfoList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PWalletGiftInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PWalletGiftInfo),
        .number = PWalletGiftInfoList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PWalletGiftInfoList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PWalletGiftInfoList class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PWalletGiftInfoList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PWalletPayPwdIsSet

@implementation PWalletPayPwdIsSet

@dynamic isset;

typedef struct PWalletPayPwdIsSet__storage_ {
  uint32_t _has_storage_[1];
} PWalletPayPwdIsSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isset",
        .dataTypeSpecific.className = NULL,
        .number = PWalletPayPwdIsSet_FieldNumber_Isset,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PWalletPayPwdIsSet class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PWalletPayPwdIsSet__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PWalletToken

@implementation PWalletToken

@dynamic token;

typedef struct PWalletToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} PWalletToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = PWalletToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PWalletToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PWalletToken class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PWalletToken__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRedPacketStatus

@implementation PRedPacketStatus

@dynamic status;

typedef struct PRedPacketStatus__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} PRedPacketStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PRedPacketStatus_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRedPacketStatus__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRedPacketStatus class]
                                     rootClass:[WalletRoot class]
                                          file:WalletRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRedPacketStatus__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: news.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "News.pbobjc.h"
 #import "Account.pbobjc.h"
 #import "Wallet.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - NewsRoot

@implementation NewsRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[AccountRoot extensionRegistry]];
    [registry addExtensions:[WalletRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - NewsRoot_FileDescriptor

static GPBFileDescriptor *NewsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"common"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - PPostInfoList

@implementation PPostInfoList

@dynamic listArray, listArray_Count;

typedef struct PPostInfoList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PPostInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PPostInfo),
        .number = PPostInfoList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PPostInfoList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PPostInfoList class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PPostInfoList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PPostInfo

@implementation PPostInfo

@dynamic id_p;
@dynamic uuid;
@dynamic userName;
@dynamic userHead;
@dynamic content;
@dynamic srcType;
@dynamic imagesArray, imagesArray_Count;
@dynamic hasVideo, video;
@dynamic hasAudio, audio;
@dynamic pubishTime;
@dynamic position;
@dynamic self_p;
@dynamic collected;
@dynamic commentCnt;
@dynamic collectCnt;
@dynamic voteCnt;
@dynamic vote;
@dynamic hasAtusers, atusers;
@dynamic isDelete;
@dynamic isHide;
@dynamic hasRedPacket, redPacket;

typedef struct PPostInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *uuid;
  NSString *userName;
  NSString *userHead;
  NSString *content;
  NSString *srcType;
  NSMutableArray *imagesArray;
  PVideo *video;
  PAudio *audio;
  NSString *position;
  PAtUserList *atusers;
  PRedPacketInfo *redPacket;
  int64_t id_p;
  int64_t pubishTime;
  int64_t commentCnt;
  int64_t collectCnt;
  int64_t voteCnt;
} PPostInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, userName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userHead",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_UserHead,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, userHead),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "srcType",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_SrcType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, srcType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PImage),
        .number = PPostInfo_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(PVideo),
        .number = PPostInfo_FieldNumber_Video,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.className = GPBStringifySymbol(PAudio),
        .number = PPostInfo_FieldNumber_Audio,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pubishTime",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_PubishTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, pubishTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_Position,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, position),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "self_p",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_Self_p,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "collected",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_Collected,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "commentCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_CommentCnt,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, commentCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "collectCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_CollectCnt,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, collectCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "voteCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_VoteCnt,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, voteCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "vote",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_Vote,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "atusers",
        .dataTypeSpecific.className = GPBStringifySymbol(PAtUserList),
        .number = PPostInfo_FieldNumber_Atusers,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, atusers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isDelete",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_IsDelete,
        .hasIndex = 20,
        .offset = 21,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isHide",
        .dataTypeSpecific.className = NULL,
        .number = PPostInfo_FieldNumber_IsHide,
        .hasIndex = 22,
        .offset = 23,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "redPacket",
        .dataTypeSpecific.className = GPBStringifySymbol(PRedPacketInfo),
        .number = PPostInfo_FieldNumber_RedPacket,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(PPostInfo__storage_, redPacket),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PPostInfo class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PPostInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\003\010\000\004\010\000\006\007\000\013\n\000\020\n\000\021\n\000\022\007\000\025H\000\026F\000\027I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PAtUserList

@implementation PAtUserList

@dynamic listArray, listArray_Count;

typedef struct PAtUserList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PAtUserList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PAtUser),
        .number = PAtUserList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PAtUserList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PAtUserList class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PAtUserList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PAtUser

@implementation PAtUser

@dynamic uuid;
@dynamic nickName;

typedef struct PAtUser__storage_ {
  uint32_t _has_storage_[1];
  NSString *uuid;
  NSString *nickName;
} PAtUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PAtUser_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PAtUser__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PAtUser_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PAtUser__storage_, nickName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PAtUser class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PAtUser__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PImage

@implementation PImage

@dynamic URL;
@dynamic hasTags, tags;
@dynamic thumbnail;
@dynamic des;

typedef struct PImage__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  PImageTagList *tags;
  NSString *thumbnail;
  NSString *des;
} PImage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PImage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PImage__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tags",
        .dataTypeSpecific.className = GPBStringifySymbol(PImageTagList),
        .number = PImage_FieldNumber_Tags,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PImage__storage_, tags),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "thumbnail",
        .dataTypeSpecific.className = NULL,
        .number = PImage_FieldNumber_Thumbnail,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PImage__storage_, thumbnail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "des",
        .dataTypeSpecific.className = NULL,
        .number = PImage_FieldNumber_Des,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PImage__storage_, des),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PImage class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PImage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001!!!\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PVideo

@implementation PVideo

@dynamic URL;
@dynamic img;
@dynamic tagsArray, tagsArray_Count;
@dynamic expires;
@dynamic type;

typedef struct PVideo__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *URL;
  NSString *img;
  NSMutableArray *tagsArray;
  int64_t expires;
} PVideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PVideo_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PVideo__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = PVideo_FieldNumber_Img,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PVideo__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PVideoTag),
        .number = PVideo_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PVideo__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expires",
        .dataTypeSpecific.className = NULL,
        .number = PVideo_FieldNumber_Expires,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PVideo__storage_, expires),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PVideo_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PVideo__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PVideo class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PVideo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PAudio

@implementation PAudio

@dynamic URL;
@dynamic length;
@dynamic expires;

typedef struct PAudio__storage_ {
  uint32_t _has_storage_[1];
  int32_t length;
  NSString *URL;
  int64_t expires;
} PAudio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PAudio_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PAudio__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "length",
        .dataTypeSpecific.className = NULL,
        .number = PAudio_FieldNumber_Length,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PAudio__storage_, length),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "expires",
        .dataTypeSpecific.className = NULL,
        .number = PAudio_FieldNumber_Expires,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PAudio__storage_, expires),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PAudio class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PAudio__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PImageTagList

@implementation PImageTagList

@dynamic listArray, listArray_Count;

typedef struct PImageTagList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PImageTagList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PImageTag),
        .number = PImageTagList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PImageTagList__storage_, listArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PImageTagList class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PImageTagList__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PImageTag

@implementation PImageTag

@dynamic type;
@dynamic subType;
@dynamic x;
@dynamic y;
@dynamic name;
@dynamic goodPrice;
@dynamic goodLink;
@dynamic personUuid;
@dynamic personName;

typedef struct PImageTag__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t subType;
  float x;
  float y;
  NSString *name;
  NSString *goodPrice;
  NSString *goodLink;
  NSString *personUuid;
  NSString *personName;
} PImageTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PImageTag_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PImageTag__storage_, type),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subType",
        .dataTypeSpecific.className = NULL,
        .number = PImageTag_FieldNumber_SubType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PImageTag__storage_, subType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = PImageTag_FieldNumber_X,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PImageTag__storage_, x),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = PImageTag_FieldNumber_Y,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PImageTag__storage_, y),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PImageTag_FieldNumber_Name,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PImageTag__storage_, name),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "goodPrice",
        .dataTypeSpecific.className = NULL,
        .number = PImageTag_FieldNumber_GoodPrice,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PImageTag__storage_, goodPrice),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "goodLink",
        .dataTypeSpecific.className = NULL,
        .number = PImageTag_FieldNumber_GoodLink,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PImageTag__storage_, goodLink),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "personUuid",
        .dataTypeSpecific.className = NULL,
        .number = PImageTag_FieldNumber_PersonUuid,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PImageTag__storage_, personUuid),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "personName",
        .dataTypeSpecific.className = NULL,
        .number = PImageTag_FieldNumber_PersonName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PImageTag__storage_, personName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PImageTag class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PImageTag__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001D\000\002G\000\003A\000\004A\000\005D\000\006I\000\007H\000\010J\000\tJ\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PVideoTag

@implementation PVideoTag

@dynamic x;
@dynamic y;
@dynamic text;

typedef struct PVideoTag__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
  NSString *text;
} PVideoTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = PVideoTag_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PVideoTag__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = PVideoTag_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PVideoTag__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PVideoTag_FieldNumber_Text,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PVideoTag__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PVideoTag class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PVideoTag__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PPostRedpacket

@implementation PPostRedpacket

@dynamic hasPost, post;
@dynamic hasRedpacket, redpacket;

typedef struct PPostRedpacket__storage_ {
  uint32_t _has_storage_[1];
  PPostInfo *post;
  PSendRedPacket *redpacket;
} PPostRedpacket__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "post",
        .dataTypeSpecific.className = GPBStringifySymbol(PPostInfo),
        .number = PPostRedpacket_FieldNumber_Post,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PPostRedpacket__storage_, post),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "redpacket",
        .dataTypeSpecific.className = GPBStringifySymbol(PSendRedPacket),
        .number = PPostRedpacket_FieldNumber_Redpacket,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PPostRedpacket__storage_, redpacket),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PPostRedpacket class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PPostRedpacket__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001D\000\002I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRecommendUser

@implementation PRecommendUser

@dynamic uuid;
@dynamic username;
@dynamic nickname;
@dynamic headImgURL;
@dynamic gender;
@dynamic membershipLevel;
@dynamic followship;
@dynamic friend_p;

typedef struct PRecommendUser__storage_ {
  uint32_t _has_storage_[1];
  int32_t gender;
  int32_t membershipLevel;
  int32_t followship;
  NSString *uuid;
  NSString *username;
  NSString *nickname;
  NSString *headImgURL;
} PRecommendUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendUser_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRecommendUser__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendUser_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PRecommendUser__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendUser_FieldNumber_Nickname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PRecommendUser__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendUser_FieldNumber_HeadImgURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PRecommendUser__storage_, headImgURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gender",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendUser_FieldNumber_Gender,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PRecommendUser__storage_, gender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "membershipLevel",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendUser_FieldNumber_MembershipLevel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PRecommendUser__storage_, membershipLevel),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "followship",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendUser_FieldNumber_Followship,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PRecommendUser__storage_, followship),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "friend_p",
        .dataTypeSpecific.className = NULL,
        .number = PRecommendUser_FieldNumber_Friend_p,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRecommendUser class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRecommendUser__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\t\n\000\013\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PFollowOrFansList

@implementation PFollowOrFansList

@dynamic listArray, listArray_Count;
@dynamic index;

typedef struct PFollowOrFansList__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  NSMutableArray *listArray;
} PFollowOrFansList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PRecommendUser),
        .number = PFollowOrFansList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PFollowOrFansList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PFollowOrFansList_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PFollowOrFansList__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PFollowOrFansList class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PFollowOrFansList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PPersonStatistic

@implementation PPersonStatistic

@dynamic friendCnt;
@dynamic followCnt;
@dynamic fansCnt;
@dynamic textCnt;
@dynamic imageCnt;
@dynamic audioCnt;
@dynamic videoCnt;

typedef struct PPersonStatistic__storage_ {
  uint32_t _has_storage_[1];
  int32_t friendCnt;
  int32_t followCnt;
  int32_t fansCnt;
  int32_t textCnt;
  int32_t imageCnt;
  int32_t audioCnt;
  int32_t videoCnt;
} PPersonStatistic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "friendCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPersonStatistic_FieldNumber_FriendCnt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PPersonStatistic__storage_, friendCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "followCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPersonStatistic_FieldNumber_FollowCnt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PPersonStatistic__storage_, followCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fansCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPersonStatistic_FieldNumber_FansCnt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PPersonStatistic__storage_, fansCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "textCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPersonStatistic_FieldNumber_TextCnt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PPersonStatistic__storage_, textCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPersonStatistic_FieldNumber_ImageCnt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PPersonStatistic__storage_, imageCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "audioCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPersonStatistic_FieldNumber_AudioCnt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PPersonStatistic__storage_, audioCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "videoCnt",
        .dataTypeSpecific.className = NULL,
        .number = PPersonStatistic_FieldNumber_VideoCnt,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PPersonStatistic__storage_, videoCnt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PPersonStatistic class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PPersonStatistic__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\t\000\002\t\000\003\007\000\004\007\000\005\010\000\006\010\000\007\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PNewsUserProfile

@implementation PNewsUserProfile

@dynamic hasUser, user;
@dynamic followship;
@dynamic friend_p;

typedef struct PNewsUserProfile__storage_ {
  uint32_t _has_storage_[1];
  int32_t followship;
  PUser *user;
} PNewsUserProfile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(PUser),
        .number = PNewsUserProfile_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PNewsUserProfile__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "followship",
        .dataTypeSpecific.className = NULL,
        .number = PNewsUserProfile_FieldNumber_Followship,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PNewsUserProfile__storage_, followship),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "friend_p",
        .dataTypeSpecific.className = NULL,
        .number = PNewsUserProfile_FieldNumber_Friend_p,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PNewsUserProfile class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PNewsUserProfile__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRelationList

@implementation PRelationList

@dynamic listArray, listArray_Count;

typedef struct PRelationList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PRelationList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PRelation),
        .number = PRelationList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PRelationList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRelationList class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRelationList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PRelation

@implementation PRelation

@dynamic ship;
@dynamic uuidA;
@dynamic uuidB;
@dynamic folsA;
@dynamic fansA;
@dynamic folsB;
@dynamic fansB;

typedef struct PRelation__storage_ {
  uint32_t _has_storage_[1];
  int32_t ship;
  int32_t folsA;
  int32_t fansA;
  int32_t folsB;
  int32_t fansB;
  NSString *uuidA;
  NSString *uuidB;
} PRelation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ship",
        .dataTypeSpecific.className = NULL,
        .number = PRelation_FieldNumber_Ship,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PRelation__storage_, ship),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "uuidA",
        .dataTypeSpecific.className = NULL,
        .number = PRelation_FieldNumber_UuidA,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PRelation__storage_, uuidA),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuidB",
        .dataTypeSpecific.className = NULL,
        .number = PRelation_FieldNumber_UuidB,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PRelation__storage_, uuidB),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "folsA",
        .dataTypeSpecific.className = NULL,
        .number = PRelation_FieldNumber_FolsA,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PRelation__storage_, folsA),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fansA",
        .dataTypeSpecific.className = NULL,
        .number = PRelation_FieldNumber_FansA,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PRelation__storage_, fansA),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "folsB",
        .dataTypeSpecific.className = NULL,
        .number = PRelation_FieldNumber_FolsB,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PRelation__storage_, folsB),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fansB",
        .dataTypeSpecific.className = NULL,
        .number = PRelation_FieldNumber_FansB,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PRelation__storage_, fansB),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PRelation class]
                                     rootClass:[NewsRoot class]
                                          file:NewsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PRelation__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\005\000\003\005\000\004\005\000\005\005\000\006\005\000\007\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

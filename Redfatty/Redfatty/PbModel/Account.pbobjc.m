// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: account.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Account.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - AccountRoot

@implementation AccountRoot

@end

#pragma mark - AccountRoot_FileDescriptor

static GPBFileDescriptor *AccountRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"common"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ELevelType

GPBEnumDescriptor *ELevelType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "User\000Vip\000Vipp\000Vo\000Tourist\000";
    static const int32_t values[] = {
        ELevelType_User,
        ELevelType_Vip,
        ELevelType_Vipp,
        ELevelType_Vo,
        ELevelType_Tourist,
    };
    static const char *extraTextFormatInfo = "\005\000\004\000\001\003\000\002\004\000\003\002\000\004\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ELevelType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ELevelType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ELevelType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ELevelType_User:
    case ELevelType_Vip:
    case ELevelType_Vipp:
    case ELevelType_Vo:
    case ELevelType_Tourist:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ERightId

GPBEnumDescriptor *ERightId_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "WeiboShowLeftCatalog\000WeiboShowTopDropdow"
        "n\000WeiboShowIcon\000WeiboShowComment\000WeiboSh"
        "owCollect\000WeiboShowMore\000WeiboShowViewDet"
        "ails\000WeiboCommentText\000WeiboCommentAudio\000"
        "WeiboPostText\000WeiboPostImage\000WeiboPostVi"
        "deo\000WeiboPostAudio\000PersonalRecordExterna"
        "lLinks\000PersonalRecordIcon\000PersonalRecord"
        "Community\000PersonalRecordVideoClassifyPag"
        "e\000PersonalRecordAudioClassifyPage\000Friend"
        "SystemRecommend\000FriendSystemSearch\000Frien"
        "dSystemFriendApplyFor\000FriendSystemAddres"
        "sBook\000FriendSystemFriend\000FriendSystemMyA"
        "pplyFor\000RealName\000";
    static const int32_t values[] = {
        ERightId_WeiboShowLeftCatalog,
        ERightId_WeiboShowTopDropdown,
        ERightId_WeiboShowIcon,
        ERightId_WeiboShowComment,
        ERightId_WeiboShowCollect,
        ERightId_WeiboShowMore,
        ERightId_WeiboShowViewDetails,
        ERightId_WeiboCommentText,
        ERightId_WeiboCommentAudio,
        ERightId_WeiboPostText,
        ERightId_WeiboPostImage,
        ERightId_WeiboPostVideo,
        ERightId_WeiboPostAudio,
        ERightId_PersonalRecordExternalLinks,
        ERightId_PersonalRecordIcon,
        ERightId_PersonalRecordCommunity,
        ERightId_PersonalRecordVideoClassifyPage,
        ERightId_PersonalRecordAudioClassifyPage,
        ERightId_FriendSystemRecommend,
        ERightId_FriendSystemSearch,
        ERightId_FriendSystemFriendApplyFor,
        ERightId_FriendSystemAddressBook,
        ERightId_FriendSystemFriend,
        ERightId_FriendSystemMyApplyFor,
        ERightId_RealName,
    };
    static const char *extraTextFormatInfo = "\031\000%\244\244\247\000\001%\244\243\250\000\002%\244\244\000\003%\244\247\000\004%\244\247\000\005%\244\244\000\006%\244\244\247\000\007%\247\244\000\010%\247\245\000\t%\244\244\000\n%\244\245\000\013%\244\245\000\014%\244\245\000\r(\246\250\245\000\016(\246\244\000\017(\246\251\000\020(\246\245\250\244\000\021(\246\245\250\244\000\022&\246\251\000\023&\246\246\000\024&\246\246\245\243\000\025&\246\247\244\000\026&\246\246\000\027&\246\242\245\243\000\030$\244\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ERightId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ERightId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ERightId_IsValidValue(int32_t value__) {
  switch (value__) {
    case ERightId_WeiboShowLeftCatalog:
    case ERightId_WeiboShowTopDropdown:
    case ERightId_WeiboShowIcon:
    case ERightId_WeiboShowComment:
    case ERightId_WeiboShowCollect:
    case ERightId_WeiboShowMore:
    case ERightId_WeiboShowViewDetails:
    case ERightId_WeiboCommentText:
    case ERightId_WeiboCommentAudio:
    case ERightId_WeiboPostText:
    case ERightId_WeiboPostImage:
    case ERightId_WeiboPostVideo:
    case ERightId_WeiboPostAudio:
    case ERightId_PersonalRecordExternalLinks:
    case ERightId_PersonalRecordIcon:
    case ERightId_PersonalRecordCommunity:
    case ERightId_PersonalRecordVideoClassifyPage:
    case ERightId_PersonalRecordAudioClassifyPage:
    case ERightId_FriendSystemRecommend:
    case ERightId_FriendSystemSearch:
    case ERightId_FriendSystemFriendApplyFor:
    case ERightId_FriendSystemAddressBook:
    case ERightId_FriendSystemFriend:
    case ERightId_FriendSystemMyApplyFor:
    case ERightId_RealName:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PUserList

@implementation PUserList

@dynamic listArray, listArray_Count;

typedef struct PUserList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PUserList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PUser),
        .number = PUserList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PUserList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PUserList class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PUserList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PLiveInfo

@implementation PLiveInfo

@dynamic website;
@dynamic URL;

typedef struct PLiveInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *website;
  NSString *URL;
} PLiveInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "website",
        .dataTypeSpecific.className = NULL,
        .number = PLiveInfo_FieldNumber_Website,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PLiveInfo__storage_, website),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PLiveInfo_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PLiveInfo__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PLiveInfo class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PLiveInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PLiveInfoList

@implementation PLiveInfoList

@dynamic listArray, listArray_Count;

typedef struct PLiveInfoList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PLiveInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PLiveInfo),
        .number = PLiveInfoList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PLiveInfoList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PLiveInfoList class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PLiveInfoList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PUser

@implementation PUser

@dynamic uuid;
@dynamic password;
@dynamic username;
@dynamic nickname;
@dynamic headImgURL;
@dynamic realname;
@dynamic gender;
@dynamic email;
@dynamic birthday;
@dynamic cellphone;
@dynamic timeZone;
@dynamic locale;
@dynamic membershipLevel;
@dynamic lastUpdateTime;
@dynamic lastLoginTime;
@dynamic userResume;
@dynamic link1;
@dynamic link2;
@dynamic link3;
@dynamic chatId;
@dynamic hasLevelInfo, levelInfo;
@dynamic disable;
@dynamic isAi;
@dynamic forceChangePwd;
@dynamic areaCode;
@dynamic areaName;
@dynamic liveRemind;
@dynamic hasLiveInfo, liveInfo;
@dynamic backImage;

typedef struct PUser__storage_ {
  uint32_t _has_storage_[2];
  int32_t gender;
  int32_t timeZone;
  int32_t membershipLevel;
  NSString *uuid;
  NSString *password;
  NSString *username;
  NSString *nickname;
  NSString *headImgURL;
  NSString *realname;
  NSString *email;
  NSString *birthday;
  NSString *cellphone;
  NSString *locale;
  NSString *userResume;
  NSString *link1;
  NSString *link2;
  NSString *link3;
  PLevelInfo *levelInfo;
  NSString *areaCode;
  NSString *areaName;
  PLiveInfoList *liveInfo;
  NSString *backImage;
  int64_t lastUpdateTime;
  int64_t lastLoginTime;
  int64_t chatId;
} PUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PUser__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PUser__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Username,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PUser__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Nickname,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PUser__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_HeadImgURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PUser__storage_, headImgURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realname",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Realname,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PUser__storage_, realname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gender",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Gender,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PUser__storage_, gender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Email,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PUser__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "birthday",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Birthday,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PUser__storage_, birthday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cellphone",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Cellphone,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PUser__storage_, cellphone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_TimeZone,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PUser__storage_, timeZone),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "locale",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Locale,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PUser__storage_, locale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "membershipLevel",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_MembershipLevel,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PUser__storage_, membershipLevel),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastUpdateTime",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_LastUpdateTime,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PUser__storage_, lastUpdateTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastLoginTime",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_LastLoginTime,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PUser__storage_, lastLoginTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userResume",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_UserResume,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PUser__storage_, userResume),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "link1",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Link1,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PUser__storage_, link1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "link2",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Link2,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PUser__storage_, link2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "link3",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Link3,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PUser__storage_, link3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatId",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_ChatId,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PUser__storage_, chatId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "levelInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PLevelInfo),
        .number = PUser_FieldNumber_LevelInfo,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PUser__storage_, levelInfo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "disable",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_Disable,
        .hasIndex = 21,
        .offset = 22,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isAi",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_IsAi,
        .hasIndex = 23,
        .offset = 24,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "forceChangePwd",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_ForceChangePwd,
        .hasIndex = 25,
        .offset = 26,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "areaCode",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_AreaCode,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(PUser__storage_, areaCode),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "areaName",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_AreaName,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(PUser__storage_, areaName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "liveRemind",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_LiveRemind,
        .hasIndex = 29,
        .offset = 30,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "liveInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PLiveInfoList),
        .number = PUser_FieldNumber_LiveInfo,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(PUser__storage_, liveInfo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backImage",
        .dataTypeSpecific.className = NULL,
        .number = PUser_FieldNumber_BackImage,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(PUser__storage_, backImage),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PUser class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PUser__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\017\n\n\000\020\010\000\022\017\000\023\016\000\024\r\000\025\n\000\031\006\000\032\t\000\034\003A\000\035\016\000\036\010\000\037\010\000 \n"
        "\000!\010\000\"\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PUserListEx

@implementation PUserListEx

@dynamic listArray, listArray_Count;

typedef struct PUserListEx__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PUserListEx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PUserEx),
        .number = PUserListEx_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PUserListEx__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PUserListEx class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PUserListEx__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PUserEx

@implementation PUserEx

@dynamic uuid;
@dynamic project;
@dynamic username;
@dynamic password;
@dynamic nickname;
@dynamic realname;
@dynamic gender;
@dynamic birthday;
@dynamic email;
@dynamic cellphone;
@dynamic timeZone;
@dynamic headImgURL;
@dynamic locale;
@dynamic userResume;
@dynamic lastUpdateTime;
@dynamic lastLoginTime;
@dynamic userData, userData_Count;

typedef struct PUserEx__storage_ {
  uint32_t _has_storage_[1];
  int32_t gender;
  int32_t timeZone;
  NSString *uuid;
  NSString *project;
  NSString *username;
  NSString *password;
  NSString *nickname;
  NSString *realname;
  NSString *birthday;
  NSString *email;
  NSString *cellphone;
  NSString *headImgURL;
  NSString *locale;
  NSString *userResume;
  NSMutableDictionary *userData;
  int64_t lastUpdateTime;
  int64_t lastLoginTime;
} PUserEx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PUserEx__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "project",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Project,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PUserEx__storage_, project),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Username,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PUserEx__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Password,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PUserEx__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Nickname,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PUserEx__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realname",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Realname,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PUserEx__storage_, realname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gender",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Gender,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PUserEx__storage_, gender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "birthday",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Birthday,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PUserEx__storage_, birthday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Email,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PUserEx__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cellphone",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Cellphone,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PUserEx__storage_, cellphone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_TimeZone,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PUserEx__storage_, timeZone),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_HeadImgURL,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PUserEx__storage_, headImgURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locale",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_Locale,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PUserEx__storage_, locale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userResume",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_UserResume,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PUserEx__storage_, userResume),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastUpdateTime",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_LastUpdateTime,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PUserEx__storage_, lastUpdateTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastLoginTime",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_LastLoginTime,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PUserEx__storage_, lastLoginTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userData",
        .dataTypeSpecific.className = NULL,
        .number = PUserEx_FieldNumber_UserData,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PUserEx__storage_, userData),
        .flags = GPBFieldMapKeyString | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PUserEx class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PUserEx__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\020\010\000\021\n\000\023\n\000\024\016\000\025\r\000\026\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PUserBase

@implementation PUserBase

@dynamic level;
@dynamic uuid;
@dynamic userName;
@dynamic nickname;
@dynamic realName;
@dynamic headImgURL;
@dynamic userResume;

typedef struct PUserBase__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
  NSString *uuid;
  NSString *userName;
  NSString *nickname;
  NSString *realName;
  NSString *headImgURL;
  NSString *userResume;
} PUserBase__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PUserBase_FieldNumber_Level,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PUserBase__storage_, level),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PUserBase_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PUserBase__storage_, uuid),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = PUserBase_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PUserBase__storage_, userName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = PUserBase_FieldNumber_Nickname,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PUserBase__storage_, nickname),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realName",
        .dataTypeSpecific.className = NULL,
        .number = PUserBase_FieldNumber_RealName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PUserBase__storage_, realName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PUserBase_FieldNumber_HeadImgURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PUserBase__storage_, headImgURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userResume",
        .dataTypeSpecific.className = NULL,
        .number = PUserBase_FieldNumber_UserResume,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PUserBase__storage_, userResume),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PUserBase class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PUserBase__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\002E\000\006d\000\007H\000\010H\000\tH\000\nJ\000\013J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PUserBaseList

@implementation PUserBaseList

@dynamic listArray, listArray_Count;

typedef struct PUserBaseList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PUserBaseList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PUserBase),
        .number = PUserBaseList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PUserBaseList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PUserBaseList class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PUserBaseList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PPhoneMap

@implementation PPhoneMap

@dynamic list, list_Count;

typedef struct PPhoneMap__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *list;
} PPhoneMap__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "list",
        .dataTypeSpecific.className = NULL,
        .number = PPhoneMap_FieldNumber_List,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PPhoneMap__storage_, list),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PPhoneMap class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PPhoneMap__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PAccount

@implementation PAccount

@dynamic cellphone;
@dynamic wechat;
@dynamic weibo;
@dynamic facebook;
@dynamic google;

typedef struct PAccount__storage_ {
  uint32_t _has_storage_[1];
} PAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cellphone",
        .dataTypeSpecific.className = NULL,
        .number = PAccount_FieldNumber_Cellphone,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "wechat",
        .dataTypeSpecific.className = NULL,
        .number = PAccount_FieldNumber_Wechat,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "weibo",
        .dataTypeSpecific.className = NULL,
        .number = PAccount_FieldNumber_Weibo,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "facebook",
        .dataTypeSpecific.className = NULL,
        .number = PAccount_FieldNumber_Facebook,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "google",
        .dataTypeSpecific.className = NULL,
        .number = PAccount_FieldNumber_Google,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PAccount class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PAccount__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PLevelInfo

@implementation PLevelInfo

@dynamic levelType;
@dynamic mapRight, mapRight_Count;

typedef struct PLevelInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t levelType;
  GPBStringBoolDictionary *mapRight;
} PLevelInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "levelType",
        .dataTypeSpecific.className = NULL,
        .number = PLevelInfo_FieldNumber_LevelType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PLevelInfo__storage_, levelType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mapRight",
        .dataTypeSpecific.className = NULL,
        .number = PLevelInfo_FieldNumber_MapRight,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PLevelInfo__storage_, mapRight),
        .flags = GPBFieldMapKeyString | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PLevelInfo class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PLevelInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PLevelInfoEx

@implementation PLevelInfoEx

@dynamic uuid;
@dynamic hasLevelInfo, levelInfo;

typedef struct PLevelInfoEx__storage_ {
  uint32_t _has_storage_[1];
  NSString *uuid;
  PLevelInfo *levelInfo;
} PLevelInfoEx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PLevelInfoEx_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PLevelInfoEx__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "levelInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PLevelInfo),
        .number = PLevelInfoEx_FieldNumber_LevelInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PLevelInfoEx__storage_, levelInfo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PLevelInfoEx class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PLevelInfoEx__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PLevelInfos

@implementation PLevelInfos

@dynamic listArray, listArray_Count;
@dynamic failUuidArray, failUuidArray_Count;

typedef struct PLevelInfos__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
  NSMutableArray *failUuidArray;
} PLevelInfos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PLevelInfoEx),
        .number = PLevelInfos_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PLevelInfos__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "failUuidArray",
        .dataTypeSpecific.className = NULL,
        .number = PLevelInfos_FieldNumber_FailUuidArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PLevelInfos__storage_, failUuidArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PLevelInfos class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PLevelInfos__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000failUuid\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBlacklist

@implementation PBlacklist

@dynamic id_p;
@dynamic val;

typedef struct PBlacklist__storage_ {
  uint32_t _has_storage_[1];
  NSString *val;
  int64_t id_p;
} PBlacklist__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PBlacklist_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PBlacklist__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "val",
        .dataTypeSpecific.className = NULL,
        .number = PBlacklist_FieldNumber_Val,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PBlacklist__storage_, val),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBlacklist class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBlacklist__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBlacklistList

@implementation PBlacklistList

@dynamic listArray, listArray_Count;

typedef struct PBlacklistList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PBlacklistList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PBlacklist),
        .number = PBlacklistList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PBlacklistList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBlacklistList class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBlacklistList__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBlacklistVal

@implementation PBlacklistVal

@dynamic listArray, listArray_Count;

typedef struct PBlacklistVal__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PBlacklistVal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = NULL,
        .number = PBlacklistVal_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PBlacklistVal__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBlacklistVal class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBlacklistVal__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBlacklistID

@implementation PBlacklistID

@dynamic listArray, listArray_Count;

typedef struct PBlacklistID__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *listArray;
} PBlacklistID__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = NULL,
        .number = PBlacklistID_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PBlacklistID__storage_, listArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBlacklistID class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBlacklistID__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBlacklistRet

@implementation PBlacklistRet

@dynamic succListArray, succListArray_Count;
@dynamic failListArray, failListArray_Count;

typedef struct PBlacklistRet__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *succListArray;
  GPBInt64Array *failListArray;
} PBlacklistRet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "succListArray",
        .dataTypeSpecific.className = NULL,
        .number = PBlacklistRet_FieldNumber_SuccListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PBlacklistRet__storage_, succListArray),
        .flags = GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "failListArray",
        .dataTypeSpecific.className = NULL,
        .number = PBlacklistRet_FieldNumber_FailListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PBlacklistRet__storage_, failListArray),
        .flags = GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBlacklistRet class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBlacklistRet__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000succList\000\002\000failList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBlacklistExRet

@implementation PBlacklistExRet

@dynamic succListArray, succListArray_Count;
@dynamic existListArray, existListArray_Count;
@dynamic failListArray, failListArray_Count;

typedef struct PBlacklistExRet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *succListArray;
  NSMutableArray *existListArray;
  NSMutableArray *failListArray;
} PBlacklistExRet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "succListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PBlacklist),
        .number = PBlacklistExRet_FieldNumber_SuccListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PBlacklistExRet__storage_, succListArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "existListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PBlacklist),
        .number = PBlacklistExRet_FieldNumber_ExistListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PBlacklistExRet__storage_, existListArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "failListArray",
        .dataTypeSpecific.className = NULL,
        .number = PBlacklistExRet_FieldNumber_FailListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PBlacklistExRet__storage_, failListArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBlacklistExRet class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBlacklistExRet__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000succList\000\002\000existList\000\003\000failList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBlacklistCount

@implementation PBlacklistCount

@dynamic count;

typedef struct PBlacklistCount__storage_ {
  uint32_t _has_storage_[1];
  int64_t count;
} PBlacklistCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PBlacklistCount_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PBlacklistCount__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBlacklistCount class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBlacklistCount__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PLiveRemind

@implementation PLiveRemind

@dynamic offOn;

typedef struct PLiveRemind__storage_ {
  uint32_t _has_storage_[1];
} PLiveRemind__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offOn",
        .dataTypeSpecific.className = NULL,
        .number = PLiveRemind_FieldNumber_OffOn,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PLiveRemind class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PLiveRemind__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PAccountToken

@implementation PAccountToken

@dynamic token;

typedef struct PAccountToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} PAccountToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = PAccountToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PAccountToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PAccountToken class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PAccountToken__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PIsReadNameInfo

@implementation PIsReadNameInfo

@dynamic isReadName;

typedef struct PIsReadNameInfo__storage_ {
  uint32_t _has_storage_[1];
} PIsReadNameInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isReadName",
        .dataTypeSpecific.className = NULL,
        .number = PIsReadNameInfo_FieldNumber_IsReadName,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PIsReadNameInfo class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PIsReadNameInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PAccountBaseInfo

@implementation PAccountBaseInfo

@dynamic isReadName;
@dynamic cellphone;

typedef struct PAccountBaseInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *cellphone;
} PAccountBaseInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isReadName",
        .dataTypeSpecific.className = NULL,
        .number = PAccountBaseInfo_FieldNumber_IsReadName,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "cellphone",
        .dataTypeSpecific.className = NULL,
        .number = PAccountBaseInfo_FieldNumber_Cellphone,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PAccountBaseInfo__storage_, cellphone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PAccountBaseInfo class]
                                     rootClass:[AccountRoot class]
                                          file:AccountRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PAccountBaseInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
